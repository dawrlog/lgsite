<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>gRPC vs REST: Which Is Right for Your Application and Why? | Dataware Logistics</title>
<meta name="keywords" content="API Development, Security, Best Practices">
<meta name="description" content="Hello everyone, today we revisit the REST architecture, while comparing it to the gRPC calls.
A microservices framework sometimes looks like a dream, but it can be a nightmare when processing data. Transiting the data with less latency is not enough nowadays. It also needs to easily connect with systems. And not only does the speed matter, but it also needs to scale to fit your computing needs while not bleeding your infrastructure costs.">
<meta name="author" content="Daniel Paes">
<link rel="canonical" href="https://www.dawrlog.com/posts/13/">
<meta name="google-site-verification" content="4599922566">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.dawrlog.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.dawrlog.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.dawrlog.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.dawrlog.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.dawrlog.com/apple-touch-icon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.dawrlog.com/posts/13/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="gRPC vs REST: Which Is Right for Your Application and Why?" />
<meta property="og:description" content="Hello everyone, today we revisit the REST architecture, while comparing it to the gRPC calls.
A microservices framework sometimes looks like a dream, but it can be a nightmare when processing data. Transiting the data with less latency is not enough nowadays. It also needs to easily connect with systems. And not only does the speed matter, but it also needs to scale to fit your computing needs while not bleeding your infrastructure costs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.dawrlog.com/posts/13/" />
<meta property="og:image" content="https://user-images.githubusercontent.com/78096758/217092871-649e97aa-3eed-4132-8d8f-b25ee2db1578.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-12-18T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://user-images.githubusercontent.com/78096758/217092871-649e97aa-3eed-4132-8d8f-b25ee2db1578.png" />
<meta name="twitter:title" content="gRPC vs REST: Which Is Right for Your Application and Why?"/>
<meta name="twitter:description" content="Hello everyone, today we revisit the REST architecture, while comparing it to the gRPC calls.
A microservices framework sometimes looks like a dream, but it can be a nightmare when processing data. Transiting the data with less latency is not enough nowadays. It also needs to easily connect with systems. And not only does the speed matter, but it also needs to scale to fit your computing needs while not bleeding your infrastructure costs."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://www.dawrlog.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "gRPC vs REST: Which Is Right for Your Application and Why?",
      "item": "https://www.dawrlog.com/posts/13/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "gRPC vs REST: Which Is Right for Your Application and Why?",
  "name": "gRPC vs REST: Which Is Right for Your Application and Why?",
  "description": "Hello everyone, today we revisit the REST architecture, while comparing it to the gRPC calls.\nA microservices framework sometimes looks like a dream, but it can be a nightmare when processing data. Transiting the data with less latency is not enough nowadays. It also needs to easily connect with systems. And not only does the speed matter, but it also needs to scale to fit your computing needs while not bleeding your infrastructure costs.",
  "keywords": [
    "API Development", "Security", "Best Practices"
  ],
  "articleBody": "Hello everyone, today we revisit the REST architecture, while comparing it to the gRPC calls.\nA microservices framework sometimes looks like a dream, but it can be a nightmare when processing data. Transiting the data with less latency is not enough nowadays. It also needs to easily connect with systems. And not only does the speed matter, but it also needs to scale to fit your computing needs while not bleeding your infrastructure costs. And the more an application is used, the harder it is to maintain it using a modular approach. Today I want to help you choose between gRPC and REST APIs as message pipelines between your services. I’ll start by presenting REST and which problems it can solve. Then I’ll dig into gRPC and some of its neat out-of-the-box capabilities and follow by talking about the upside of gRPC architecture. I want to end this post with a guide to choosing one or the other for your application. And I’ll show you which is better than the other when it comes to each point. I’ll end by summarizing what to keep in mind when architecting your microservices. In what consists the REST architecture?\nLet’s start with the well known REST architecture. The RESTful architecture follows a stateless pattern, which means that each service carries all its metadata within it. Its messages, also called payloads, are stored using JSON format.\nIn addition, it’s easier to catch unwanted requests from your clients using REST. The architecture uses http methods for its service interactions, and methods are components that follow the same CRUD operations found on relational database applications to retain your transactions indenpendency and data consistency.\nWhen you use these methods, your data remains consistent in every layer of your application. And thanks to those characteristics, REST calls can handle your resources maintanance in a smoother way, even where network connectivity could be an issue.\nRESTful applications are also capable of storing locally the most-used data locally on the client side; technique called caching. By doing so, REST services will access the most recurrent services, which results in reduced latency and bandwidth. It becomes faster since the requested data is locally stored while the session is active. In this case, your web service returns the cached version of your information gathered by a previous call. There are some security control procedures to mitigate some problems. These procedures are not only related to the persistent caching policy to avoid the usage of non-relevant data and manage the infrastructure and data protection for your data in transit and your data at rest. Take a look at the high-level RESTful architecture below.\nRESTFul web service architecture.\nI hope that works as an introduction to or refresher on how RESTful architecture works. Next, let’s explore the problems it can solve. Challenges We Can Solve with REST\nWe can start by stating that REST API has been around for a while, and it’s more mature than gRPC. Naturally, it has better support and higher-quality documentation since it has gone through multiple stress tests over the years. Providing you easier integration of new data sources into your data pipelines; allowing it to remain closer to your data sources. Reducing problems related to network within your ecosystem and data transit in and out of your data flows.\nUsing the REST framework, you must develop each publisher and subscriber code, which allows extra data transformation logic needed to transmit your data between services properly. Another perk comes from a more robust framework, making onboarding your team more manageable by using technologies proven to handle your workload. When your messages are in a human-friendly format like JSON, auditing your pipelines becomes less painful when a failure occurs.\nEach endpoint embeds its documentation in the code, which makes a REST API easier for humans to interact with. Its actions follow a straightforward structure, with activities described by verbs. It makes more sense, for example, that the method GET is used to access records. And REST APIs are remarkably well structured, helping their maintainers and users enhance existing applications. Now that we have seen what REST can do for us let’s look at gRPC. What Is gRPC?\nThe gRPC framework is an extension of remote procedure calls. In addition to using simple messages, this framework allows multiple message requests on the same connection. And it gets better with the support of bidirectional data streaming. This feature turns the gRPC into a powerful ally. You will be able to handle multiple independent, nonrelated threads.\nThe gRPC framework uses protocol buffers (or protobuf) under the hood, allowing evolutive schema support for your streaming data. You can avoid some of the trouble of having different JSON payloads from your sources as there is no need for client libraries to handle data cleansing jobs like auditing missing JSON fundamental values.\nIn addition to removing some of your business logic while extracting data from your API calls, protocol buffers are more optimal. Your data pipelines become more performant, and as a result, you can feel the network latency of your data ingestion channels lowered even with the smaller chunks of data. It becomes easier to correlate different data sources with adaptive client-server libraries generation based on your original protobuf file. gRPC connectivity overview.\nSee the Protocol Buffers language guide for further analysis on configuring your message. Next, let’s now look at what we can solve using gRPC. Challenges We Can Solve with gRPC.\ngRPC has one significant advantage: it can create one client for a couple of clients on different programming languages out of the box. That by itself makes the adoption of your sources more accessible from a development standpoint, and you won’t need a whole development pipeline for changes in your client libraries. By simply changing your proto file, the programming language or platform of your choice can easily replicate its changes. Not only that, but your proto file can even define message routing, removing the need to configure it on each of the producer or consumer codes.\nAnother attractive characteristic of gRPC is that it’s significantly faster than HTTPS and has lightweight message sizes compared to JSON. This makes it essential when different programming languages consume your service. Using gRPC, you won’t have to struggle as much when managing your communication. While this can make it quite tempting, a successful deployment will depend on whether or not your ecosystem is mature enough to enable it. Conclusion\nI covered communication protocols used on two microservice architectures, the gRPC and the REST frameworks. It may seem attractive to adopt gRPC since it’s faster and more quickly adopted, but you can create a lot of trouble for yourself when adjusting your processing pipelines. The main reason comes from how gRPC handles the messages. You can tackle this with the out-of-the-box protobuf JSON mapping, but you will still need to change your existing REST services so that they interact with the new gRPC services. Keep in mind that not every browser supports all gRPC capabilities, so it’s not an excellent user-facing framework.\nYou’ll need a well-designed technical blueprint to change your architecture from REST to gRPC. But you’ll get a better observability plan. Having your data in a non-human format can bolster your security as your data won’t be in plain text.\nIt is also good to reinforce that Neither approach will work well without a robust security analysis, it is a good idea to revisit your rules based on the metrics of your data traffic.\nFor further help transforming your data, you can reach out to us with any questions you have and even discover new info you weren’t aware of with a better insight from better understanding your data.\nSee you next time!\n",
  "wordCount" : "1289",
  "inLanguage": "en",
  "image":"https://user-images.githubusercontent.com/78096758/217092871-649e97aa-3eed-4132-8d8f-b25ee2db1578.png","datePublished": "2022-12-18T00:00:00Z",
  "dateModified": "2022-12-18T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Daniel Paes"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.dawrlog.com/posts/13/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Dataware Logistics",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.dawrlog.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.dawrlog.com/" accesskey="h" title="Dataware Logistics (Alt + H)">Dataware Logistics</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://www.dawrlog.com/fr/" title="French"
                            aria-label=":fr:">🇫🇷</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.dawrlog.com/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.dawrlog.com/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://calendly.com/dawrlog" title="Contact">
                    <span>Contact</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://www.dawrlog.com/">Home</a>&nbsp;»&nbsp;<a href="https://www.dawrlog.com/posts/">Posts</a></div>
    <h1 class="post-title">
      gRPC vs REST: Which Is Right for Your Application and Why?
    </h1>
    <div class="post-meta"><span title='2022-12-18 00:00:00 +0000 UTC'>December 18, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Daniel Paes

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://user-images.githubusercontent.com/78096758/217092871-649e97aa-3eed-4132-8d8f-b25ee2db1578.png" alt="">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#h2in-what-consists-the-rest-architectureh2br-"><h2>In what consists the REST architecture?</h2><br /></a></li>
    <li><a href="#h3challenges-we-can-solve-with-resth3br-"><h3>Challenges We Can Solve with REST</h3><br /></a></li>
    <li><a href="#h2what-is-grpch2br-"><h2>What Is gRPC?</h2><br /></a></li>
    <li><a href="#h3challenges-we-can-solve-with-grpch3br-"><h3>Challenges We Can Solve with gRPC.</h3><br /></a></li>
    <li><a href="#h2conclusionh2br-"><h2>Conclusion</h2><br /></a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>Hello everyone, today we revisit the REST architecture, while comparing it to the gRPC calls.</p>
<p>A microservices framework sometimes looks like a dream, but it can be a nightmare when processing data. Transiting the data with less latency is not enough nowadays. It also needs to easily connect with systems. And not only does the speed matter, but it also needs to scale to fit your computing needs while not bleeding your infrastructure costs. And the more an application is used, the harder it is to maintain it using a modular approach.
Today I want to help you choose between gRPC and REST APIs as message pipelines between your services. I&rsquo;ll start by presenting REST and which problems it can solve. Then I&rsquo;ll dig into gRPC and some of its neat out-of-the-box capabilities and follow by talking about the upside of gRPC architecture. I want to end this post with a guide to choosing one or the other for your application. And I&rsquo;ll show you which is better than the other when it comes to each point. I&rsquo;ll end by summarizing what to keep in mind when architecting your microservices.
<br /><br /></p>
<h2 id="h2in-what-consists-the-rest-architectureh2br-"><h2>In what consists the REST architecture?</h2><br /><a hidden class="anchor" aria-hidden="true" href="#h2in-what-consists-the-rest-architectureh2br-">#</a></h2>
<p>Let&rsquo;s start with the well known REST architecture. The RESTful architecture follows a <a href="https://whatis.techtarget.com/definition/stateless">stateless pattern</a>, which means that each service carries all its metadata within it. Its messages, also called payloads, are stored using JSON format.</p>
<p>In addition, it&rsquo;s easier to catch unwanted requests from your clients using REST. The architecture uses <a href="https://restfulapi.net/http-methods/">http methods</a> for its service interactions, and methods are components that follow the same <a href="https://www.techtarget.com/searchdatamanagement/definition/CRUD-cycle?_gl=1*14yg8z1*_ga*Mzg5NjExNjY2LjE2NDI4MDE1MzY.*_ga_TQKE4GS5P9*MTY0NjE3MTM2NS41LjEuMTY0NjE3MTk4NC4w&amp;_ga=2.113472391.1839572985.1646171366-389611666.1642801536">CRUD operations</a> found on <a href="https://www.techtarget.com/searchdatamanagement/definition/relational-database">relational database</a> applications to retain your transactions indenpendency and data consistency.</p>
<p>When you use these methods, your data remains consistent in every layer of your application. And thanks to those characteristics, REST calls can handle your <a href="https://restfulapi.net/resource-naming/">resources maintanance</a> in a smoother way, even where network connectivity could be an issue.</p>
<p>RESTful applications are also capable of storing locally the most-used data locally on the client side; technique called <a href="https://restfulapi.net/caching/">caching</a>. By doing so, REST services will access the most recurrent services, which results in reduced latency and bandwidth. It becomes faster since the requested data is locally stored while the session is active. In this case, your web service returns the cached version of your information gathered by a previous call. There are some <a href="https://restfulapi.net/security-essentials/">security control procedures</a> to mitigate some problems. These procedures are not only related to the persistent caching policy to avoid the usage of non-relevant data and manage the infrastructure and data protection for your <a href="https://en.wikipedia.org/wiki/Data_in_transit">data in transit</a> and your <a href="https://en.wikipedia.org/wiki/Data_at_rest">data at rest</a>. Take a look at the high-level RESTful architecture below.</p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/78096758/217092492-4ed0fab0-9372-40c6-960b-7e2cea8698d3.png" alt="Rest"  />

<em>RESTFul web service architecture.</em></p>
<p> 
I hope that works as an introduction to or refresher on how RESTful architecture works. Next, let&rsquo;s explore the problems it can solve.
<br /><br /></p>
<h2 id="h3challenges-we-can-solve-with-resth3br-"><h3>Challenges We Can Solve with REST</h3><br /><a hidden class="anchor" aria-hidden="true" href="#h3challenges-we-can-solve-with-resth3br-">#</a></h2>
<p>We can start by stating that REST API has been around for a while, and it&rsquo;s more mature than gRPC. Naturally, it has better support and higher-quality documentation since it has gone through multiple stress tests over the years. Providing you easier integration of new data sources into your data pipelines; allowing it to remain closer to your data sources. Reducing problems related to network within your ecosystem and data transit in and out of your data flows.</p>
<p>Using the REST framework, you must develop each publisher and subscriber code, which allows extra data transformation logic needed to transmit your data between services properly. Another perk comes from a more robust framework, making onboarding your team more manageable by using technologies proven to handle your workload. When your messages are in a human-friendly format like JSON, auditing your pipelines becomes less painful when a failure occurs.</p>
<p>Each endpoint embeds its documentation in the code, which makes a REST API easier for humans to interact with. Its actions follow a straightforward structure, with activities described by verbs. It makes more sense, for example, that the method GET is used to access records. And REST APIs are remarkably well structured, helping their maintainers and users enhance existing applications.
Now that we have seen what REST can do for us let&rsquo;s look at gRPC.
<br /><br /></p>
<h2 id="h2what-is-grpch2br-"><h2>What Is gRPC?</h2><br /><a hidden class="anchor" aria-hidden="true" href="#h2what-is-grpch2br-">#</a></h2>
<p>The <a href="https://grpc.io/">gRPC framework</a> is an extension of remote procedure calls. In addition to using simple messages, this framework allows multiple message requests on the same connection. And it gets better with the support of <a href="https://grpc.io/docs/what-is-grpc/core-concepts/#bidirectional-streaming-rpc">bidirectional data streaming</a>. This feature turns the gRPC into a powerful ally. You will be able to handle multiple independent, nonrelated threads.</p>
<p>The gRPC framework uses protocol buffers (or <a href="https://developers.google.com/protocol-buffers/docs/overview">protobuf</a>) under the hood, allowing evolutive schema support for your streaming data. You can avoid some of the trouble of having different JSON payloads from your sources as there is no need for client libraries to handle data cleansing jobs like auditing missing JSON fundamental values.</p>
<p>In addition to removing some of your business logic while extracting data from your API calls, protocol buffers are more optimal. Your data pipelines become more performant, and as a result, you can feel the network latency of your data ingestion channels lowered even with the smaller chunks of data. It becomes easier to correlate different data sources with adaptive client-server libraries generation based on your original protobuf file.
<br /><br /></p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/78096758/217093080-4040c5d0-9e4e-4d5e-a143-4e1069e70606.png" alt="grpc-architecture"  />

<em>gRPC connectivity overview.</em></p>
<p> 
See the <a href="https://developers.google.com/protocol-buffers/docs/proto3#simple">Protocol Buffers language guide</a> for further analysis on configuring your message. Next, let&rsquo;s now look at what we can solve using gRPC.
<br /><br /></p>
<h2 id="h3challenges-we-can-solve-with-grpch3br-"><h3>Challenges We Can Solve with gRPC.</h3><br /><a hidden class="anchor" aria-hidden="true" href="#h3challenges-we-can-solve-with-grpch3br-">#</a></h2>
<p>gRPC has one significant advantage: it can create one client for a couple of <strong><em>clients on different programming languages</em></strong> out of the box. That by itself makes the adoption of your sources more accessible from a development standpoint, and you won&rsquo;t need a whole development pipeline for changes in your client libraries. By simply changing your proto file, the <a href="https://grpc.io/docs/languages/">programming language</a> or <a href="https://grpc.io/docs/platforms/">platform</a> of your choice can easily replicate its changes. Not only that, but your proto file can even define message routing, removing the need to configure it on each of the producer or consumer codes.</p>
<p>Another attractive characteristic of gRPC is that it&rsquo;s significantly faster than HTTPS and has <a href="https://auth0.com/blog/beating-json-performance-with-protobuf/">lightweight message sizes compared to JSON</a>. This makes it essential when different programming languages consume your service. Using gRPC, you won&rsquo;t have to struggle as much when managing your communication. While this can make it quite tempting, a successful deployment will depend on whether or not your ecosystem is mature enough to enable it.
<br /><br /></p>
<h2 id="h2conclusionh2br-"><h2>Conclusion</h2><br /><a hidden class="anchor" aria-hidden="true" href="#h2conclusionh2br-">#</a></h2>
<p>I covered communication protocols used on two microservice architectures, the gRPC and the REST frameworks. It may seem attractive to adopt gRPC since it&rsquo;s faster and more quickly adopted, but you can create a lot of trouble for yourself when adjusting your processing pipelines. The main reason comes from how gRPC handles the messages. You can tackle this with the out-of-the-box protobuf <a href="https://developers.google.com/protocol-buffers/docs/proto3#json">JSON mapping</a>, but you will still need to change your existing REST services so that they interact with the new gRPC services. Keep in mind that not every browser supports all gRPC capabilities, so it&rsquo;s not an excellent user-facing framework.</p>
<p>You&rsquo;ll need a well-designed technical blueprint to change your architecture from REST to gRPC. But you&rsquo;ll get a better observability plan. Having your data in a non-human format can bolster your security as your data won&rsquo;t be in plain text.</p>
<p>It is also good to reinforce that Neither approach will work well without a robust security analysis, it is a good idea to revisit your rules based on the metrics of your data traffic.</p>
<p>For further help transforming your data, you can <a href="https://calendly.com/dawrlog">reach out to us</a> with any questions you have and even discover new info you weren&rsquo;t aware of with a better insight from better understanding your data.</p>
<p>See you next time!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.dawrlog.com/tags/api-development/">API Development</a></li>
      <li><a href="https://www.dawrlog.com/tags/security/">Security</a></li>
      <li><a href="https://www.dawrlog.com/tags/best-practices/">Best Practices</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://www.dawrlog.com/posts/8/">
    <span class="title">« Prev</span>
    <br>
    <span>Incremental Loading: The Smarter Way to Update Data</span>
  </a>
  <a class="next" href="https://www.dawrlog.com/posts/5/">
    <span class="title">Next »</span>
    <br>
    <span>Argo Workflow ETL Examples.</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Which Is Right for Your Application and Why? on twitter"
        href="https://twitter.com/intent/tweet/?text=gRPC%20vs%20REST%3a%20Which%20Is%20Right%20for%20Your%20Application%20and%20Why%3f&amp;url=https%3a%2f%2fwww.dawrlog.com%2fposts%2f13%2f&amp;hashtags=APIDevelopment%2cSecurity%2cBestPractices">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Which Is Right for Your Application and Why? on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.dawrlog.com%2fposts%2f13%2f&amp;title=gRPC%20vs%20REST%3a%20Which%20Is%20Right%20for%20Your%20Application%20and%20Why%3f&amp;summary=gRPC%20vs%20REST%3a%20Which%20Is%20Right%20for%20Your%20Application%20and%20Why%3f&amp;source=https%3a%2f%2fwww.dawrlog.com%2fposts%2f13%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Which Is Right for Your Application and Why? on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fwww.dawrlog.com%2fposts%2f13%2f&title=gRPC%20vs%20REST%3a%20Which%20Is%20Right%20for%20Your%20Application%20and%20Why%3f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Which Is Right for Your Application and Why? on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.dawrlog.com%2fposts%2f13%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Which Is Right for Your Application and Why? on whatsapp"
        href="https://api.whatsapp.com/send?text=gRPC%20vs%20REST%3a%20Which%20Is%20Right%20for%20Your%20Application%20and%20Why%3f%20-%20https%3a%2f%2fwww.dawrlog.com%2fposts%2f13%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Which Is Right for Your Application and Why? on telegram"
        href="https://telegram.me/share/url?text=gRPC%20vs%20REST%3a%20Which%20Is%20Right%20for%20Your%20Application%20and%20Why%3f&amp;url=https%3a%2f%2fwww.dawrlog.com%2fposts%2f13%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://www.dawrlog.com/">Dataware Logistics</a>; <br /> created with 🧡 on 🐧 machines running ☸️ pods.</span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script>
  kofiWidgetOverlay.draw('dawrlog', {
    'type': 'floating-chat',
    'floating-chat.donateButton.text': 'Tip jar',
    'floating-chat.donateButton.background-color': '#794bc4',
    'floating-chat.donateButton.text-color': '#fff'
  });
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
