<!DOCTYPE html>
<html lang="fr" dir="fr">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi? | Logistique Dataware</title>
<meta name="keywords" content="API Development, Security, Best Practices">
<meta name="description" content="Bonjour à tous, aujourd&rsquo;hui nous revisitons l&rsquo;architecture REST, tout en la comparant aux appels gRPC.
Un framework microservices ressemble parfois à un rêve, mais il peut devenir un cauchemar lors du traitement des données. De nos jours, il ne suffit pas de faire transiter les données avec moins de latence. Il faut aussi qu&rsquo;elles se connectent facilement aux systèmes. La vitesse n&rsquo;est pas le seul critère important, il faut aussi que l&rsquo;application puisse s&rsquo;adapter à vos besoins informatiques sans faire exploser vos coûts d&rsquo;infrastructure.">
<meta name="author" content="Daniel Paes">
<link rel="canonical" href="https://www.dawrlog.com/fr/articles/13/">
<meta name="google-site-verification" content="4599922566">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.dawrlog.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.dawrlog.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.dawrlog.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.dawrlog.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.dawrlog.com/apple-touch-icon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="fr" href="https://www.dawrlog.com/fr/articles/13/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi?" />
<meta property="og:description" content="Bonjour à tous, aujourd&rsquo;hui nous revisitons l&rsquo;architecture REST, tout en la comparant aux appels gRPC.
Un framework microservices ressemble parfois à un rêve, mais il peut devenir un cauchemar lors du traitement des données. De nos jours, il ne suffit pas de faire transiter les données avec moins de latence. Il faut aussi qu&rsquo;elles se connectent facilement aux systèmes. La vitesse n&rsquo;est pas le seul critère important, il faut aussi que l&rsquo;application puisse s&rsquo;adapter à vos besoins informatiques sans faire exploser vos coûts d&rsquo;infrastructure." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.dawrlog.com/fr/articles/13/" />
<meta property="og:image" content="https://user-images.githubusercontent.com/78096758/217092871-649e97aa-3eed-4132-8d8f-b25ee2db1578.png" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2022-12-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-12-18T00:00:00+00:00" /><meta property="og:site_name" content="Logistique Dataware" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://user-images.githubusercontent.com/78096758/217092871-649e97aa-3eed-4132-8d8f-b25ee2db1578.png" />
<meta name="twitter:title" content="gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi?"/>
<meta name="twitter:description" content="Bonjour à tous, aujourd&rsquo;hui nous revisitons l&rsquo;architecture REST, tout en la comparant aux appels gRPC.
Un framework microservices ressemble parfois à un rêve, mais il peut devenir un cauchemar lors du traitement des données. De nos jours, il ne suffit pas de faire transiter les données avec moins de latence. Il faut aussi qu&rsquo;elles se connectent facilement aux systèmes. La vitesse n&rsquo;est pas le seul critère important, il faut aussi que l&rsquo;application puisse s&rsquo;adapter à vos besoins informatiques sans faire exploser vos coûts d&rsquo;infrastructure."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://www.dawrlog.com/fr/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi?",
      "item": "https://www.dawrlog.com/fr/articles/13/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi?",
  "name": "gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi?",
  "description": "Bonjour à tous, aujourd\u0026rsquo;hui nous revisitons l\u0026rsquo;architecture REST, tout en la comparant aux appels gRPC.\nUn framework microservices ressemble parfois à un rêve, mais il peut devenir un cauchemar lors du traitement des données. De nos jours, il ne suffit pas de faire transiter les données avec moins de latence. Il faut aussi qu\u0026rsquo;elles se connectent facilement aux systèmes. La vitesse n\u0026rsquo;est pas le seul critère important, il faut aussi que l\u0026rsquo;application puisse s\u0026rsquo;adapter à vos besoins informatiques sans faire exploser vos coûts d\u0026rsquo;infrastructure.",
  "keywords": [
    "API Development", "Security", "Best Practices"
  ],
  "articleBody": "Bonjour à tous, aujourd’hui nous revisitons l’architecture REST, tout en la comparant aux appels gRPC.\nUn framework microservices ressemble parfois à un rêve, mais il peut devenir un cauchemar lors du traitement des données. De nos jours, il ne suffit pas de faire transiter les données avec moins de latence. Il faut aussi qu’elles se connectent facilement aux systèmes. La vitesse n’est pas le seul critère important, il faut aussi que l’application puisse s’adapter à vos besoins informatiques sans faire exploser vos coûts d’infrastructure. Et plus une application est utilisée, plus il est difficile de la maintenir en utilisant une approche modulaire. Aujourd’hui, je veux vous aider à choisir entre les API gRPC et REST comme pipelines de messages entre vos services. Je commencerai par présenter REST et les problèmes qu’elle peut résoudre. Ensuite, je m’intéresserai à gRPC et à certaines de ses fonctionnalités prêtes à l’emploi, avant d’évoquer les avantages de l’architecture gRPC. Je souhaite terminer cet article par un guide permettant de choisir l’une ou l’autre solution pour votre application. Et je vous montrerai lequel des deux est meilleur que l’autre sur chaque point. Je terminerai en résumant ce qu’il faut garder à l’esprit lors de l’architecture de vos microservices. En quoi consiste l’architecture REST ? Commençons par l’architecture REST bien connue. L’architecture REST suit un modèle sans état, ce qui signifie que chaque service porte en lui toutes ses métadonnées. Ses messages, également appelés charges utiles, sont stockés au format JSON.\nEn outre, il est plus facile d’intercepter les demandes non désirées de vos clients en utilisant REST. L’architecture utilise des méthodes http pour ses interactions avec les services. Les méthodes sont des composants qui suivent les mêmes CRUD operations trouvées sur les applications de base de données relationnelle pour conserver l’indépendance de vos transactions et la cohérence de vos données.\nLorsque vous utilisez ces méthodes, vos données restent cohérentes dans toutes les couches de votre application. Et grâce à ces caractéristiques, les appels REST peuvent gérer votre maintenance des ressources de manière plus fluide, même lorsque la connectivité réseau peut poser problème.\nLes applications RESTful sont également capables de stocker localement les données les plus utilisées côté client ; technique appelée mise en cache. Ce faisant, les services REST accèdent aux services les plus récurrents, ce qui permet de réduire la latence et la bande passante. Il devient plus rapide puisque les données demandées sont stockées localement pendant que la session est active. Dans ce cas, votre service web renvoie la version en cache de vos informations recueillies par un appel précédent. Il existe certaines procédures de contrôle de la sécurité pour atténuer certains problèmes. Ces procédures ne sont pas seulement liées à la politique de mise en cache persistante pour éviter l’utilisation de données non pertinentes et gérer l’infrastructure et la protection des données pour vos données en transit et vos données au repos. Jetez un coup d’œil à l’architecture RESTful de haut niveau ci-dessous.\nArchitecture de service web RESTFul.\nJ’espère que cela vous permettra de vous familiariser ou de vous rafraîchir la mémoire sur le fonctionnement de l’architecture RESTful. Ensuite, nous allons explorer les problèmes qu’elle peut résoudre. Défis que nous pouvons résoudre avec REST\nNous pouvons commencer par dire que l’API REST existe depuis un certain temps et qu’elle est plus mature que gRPC. Naturellement, elle bénéficie d’un meilleur support et d’une documentation de meilleure qualité puisqu’elle a subi de nombreux tests de résistance au fil des ans. En vous permettant d’intégrer plus facilement de nouvelles sources de données dans vos pipelines de données ; en lui permettant de rester plus proche de vos sources de données. Réduire les problèmes liés au réseau au sein de votre écosystème et au transit des données dans et hors de vos flux de données.\nEn utilisant le framework REST, vous devez développer chaque code d’éditeur et d’abonné, ce qui permet une logique de transformation de données supplémentaire nécessaire pour transmettre correctement vos données entre les services. Un autre avantage provient d’un cadre plus robuste, rendant l’intégration de votre équipe plus facile à gérer en utilisant des technologies éprouvées pour gérer votre charge de travail. Lorsque vos messages sont dans un format convivial comme JSON, l’audit de vos pipelines devient moins pénible lorsqu’une défaillance se produit.\nChaque point de terminaison intègre sa documentation dans le code, ce qui rend l’API REST plus facile à utiliser pour les humains. Ses actions suivent une structure simple, les activités étant décrites par des verbes. Il est plus logique, par exemple, que la méthode GET soit utilisée pour accéder à des enregistrements. De plus, les API REST sont remarquablement bien structurées, ce qui aide leurs responsables et leurs utilisateurs à améliorer les applications existantes. Maintenant que nous avons vu ce que REST peut faire pour nous, examinons gRPC. Qu’est-ce que gRPC ? The gRPC framework is an extension of remote procedure calls. In addition to using simple messages, this framework allows multiple message requests on the same connection. And it gets better with the support of bidirectional data streaming. This feature turns the gRPC into a powerful ally. You will be able to handle multiple independent, nonrelated threads.\nThe gRPC framework uses protocol buffers (or protobuf) under the hood, allowing evolutive schema support for your streaming data. You can avoid some of the trouble of having different JSON payloads from your sources as there is no need for client libraries to handle data cleansing jobs like auditing missing JSON fundamental values.\nIn addition to removing some of your business logic while extracting data from your API calls, protocol buffers are more optimal. Your data pipelines become more performant, and as a result, you can feel the network latency of your data ingestion channels lowered even with the smaller chunks of data. It becomes easier to correlate different data sources with adaptive client-server libraries generation based on your original protobuf file. gRPC connectivity overview.\nConsultez le Guide de langage des tampons de protocole pour une analyse plus approfondie de la configuration de votre message. Voyons maintenant ce que nous pouvons résoudre à l’aide de gRPC. Des défis que nous pouvons résoudre avec gRPC.\ngRPC a un avantage significatif : il peut créer un client pour deux clients sur différents langages de programmation dès le départ. En soi, cela rend l’adoption de vos sources plus accessible du point de vue du développement, et vous n’aurez pas besoin de tout un pipeline de développement pour les changements dans vos bibliothèques clientes. En modifiant simplement votre fichier proto, le langage de programmation ou la plate-forme de votre choix peut facilement reproduire ses modifications. De plus, votre fichier proto peut même définir l’acheminement des messages, ce qui évite de devoir le configurer sur chacun des codes producteurs ou consommateurs.\nUne autre caractéristique intéressante de gRPC est qu’il est nettement plus rapide que HTTPS et que la taille des messages est plus légère que celle de JSON (https://auth0.com/blog/beating-json-performance-with-protobuf/). Cela le rend essentiel lorsque différents langages de programmation consomment votre service. En utilisant gRPC, vous n’aurez pas à vous battre autant pour gérer votre communication. Bien que cela puisse être très tentant, un déploiement réussi dépendra de la maturité de votre écosystème pour le permettre. Conclusion\nJ’ai couvert les protocoles de communication utilisés sur deux architectures de microservices, les frameworks gRPC et REST. Il peut sembler intéressant d’adopter gRPC car il est plus rapide et plus vite adopté, mais vous risquez de vous créer beaucoup d’ennuis en ajustant vos pipelines de traitement. La raison principale vient de la façon dont gRPC traite les messages. Vous pouvez y remédier avec le protobuf mappage JSON prêt à l’emploi, mais vous devrez tout de même modifier vos services REST existants pour qu’ils interagissent avec les nouveaux services gRPC. Gardez à l’esprit que tous les navigateurs ne prennent pas en charge toutes les fonctionnalités de gRPC, et qu’il ne s’agit donc pas d’un excellent cadre de travail pour l’utilisateur.\nVous aurez besoin d’un plan technique bien conçu pour faire passer votre architecture de REST à gRPC. Mais vous obtiendrez un meilleur plan d’observabilité. Le fait d’avoir vos données dans un format non humain peut renforcer votre sécurité car vos données ne seront pas en texte clair.\nIl est également bon de renforcer que Aucune approche ne fonctionnera bien sans une analyse de sécurité robuste, c’est une bonne idée de revoir vos règles en fonction des métriques de votre trafic de données.\nSi vous avez besoin d’aide pour transformer vos données, vous pouvez nous contacter pour toute question et même découvrir de nouvelles informations dont vous n’étiez pas conscient grâce à une meilleure compréhension de vos données.\nÀ+!\n",
  "wordCount" : "1435",
  "inLanguage": "fr",
  "image":"https://user-images.githubusercontent.com/78096758/217092871-649e97aa-3eed-4132-8d8f-b25ee2db1578.png","datePublished": "2022-12-18T00:00:00Z",
  "dateModified": "2022-12-18T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Daniel Paes"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.dawrlog.com/fr/articles/13/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Logistique Dataware",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.dawrlog.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.dawrlog.com/fr/" accesskey="h" title="Logistique Dataware (Alt + H)">Logistique Dataware</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://www.dawrlog.com/" title="English"
                            aria-label=":us:">🇺🇸</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.dawrlog.com/fr/apropos" title="À Propos">
                    <span>À Propos</span>
                </a>
            </li>
            <li>
                <a href="https://www.dawrlog.com/fr/articles/" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://calendly.com/dawrlog" title="Contactez-nous">
                    <span>Contactez-nous</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://www.dawrlog.com/fr/">Accueil</a>&nbsp;»&nbsp;<a href="https://www.dawrlog.com/fr/articles/">Articles</a></div>
    <h1 class="post-title">
      gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi?
    </h1>
    <div class="post-meta"><span title='2022-12-18 00:00:00 +0000 UTC'>décembre 18, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Daniel Paes

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://user-images.githubusercontent.com/78096758/217092871-649e97aa-3eed-4132-8d8f-b25ee2db1578.png" alt="">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table des matières</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#h2en-quoi-consiste-larchitecture-rest--h2br-"><h2>En quoi consiste l&rsquo;architecture REST ? </h2><br /></a></li>
    <li><a href="#h3défis-que-nous-pouvons-résoudre-avec-resth3br-"><h3>Défis que nous pouvons résoudre avec REST</h3><br /></a></li>
    <li><a href="#h2quest-ce-que-grpc--h2br-"><h2>Qu&rsquo;est-ce que gRPC ? </h2><br /></a></li>
    <li><a href="#h3des-défis-que-nous-pouvons-résoudre-avec-grpch3br-"><h3>Des défis que nous pouvons résoudre avec gRPC.</h3><br /></a></li>
    <li><a href="#h2conclusionh2br-"><h2>Conclusion</h2><br /></a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>Bonjour à tous, aujourd&rsquo;hui nous revisitons l&rsquo;architecture REST, tout en la comparant aux appels gRPC.</p>
<p>Un framework microservices ressemble parfois à un rêve, mais il peut devenir un cauchemar lors du traitement des données. De nos jours, il ne suffit pas de faire transiter les données avec moins de latence. Il faut aussi qu&rsquo;elles se connectent facilement aux systèmes. La vitesse n&rsquo;est pas le seul critère important, il faut aussi que l&rsquo;application puisse s&rsquo;adapter à vos besoins informatiques sans faire exploser vos coûts d&rsquo;infrastructure. Et plus une application est utilisée, plus il est difficile de la maintenir en utilisant une approche modulaire.
Aujourd&rsquo;hui, je veux vous aider à choisir entre les API gRPC et REST comme pipelines de messages entre vos services. Je commencerai par présenter REST et les problèmes qu&rsquo;elle peut résoudre. Ensuite, je m&rsquo;intéresserai à gRPC et à certaines de ses fonctionnalités prêtes à l&rsquo;emploi, avant d&rsquo;évoquer les avantages de l&rsquo;architecture gRPC. Je souhaite terminer cet article par un guide permettant de choisir l&rsquo;une ou l&rsquo;autre solution pour votre application. Et je vous montrerai lequel des deux est meilleur que l&rsquo;autre sur chaque point. Je terminerai en résumant ce qu&rsquo;il faut garder à l&rsquo;esprit lors de l&rsquo;architecture de vos microservices.
<br /><br /></p>
<h2 id="h2en-quoi-consiste-larchitecture-rest--h2br-"><h2>En quoi consiste l&rsquo;architecture REST ? </h2><br /><a hidden class="anchor" aria-hidden="true" href="#h2en-quoi-consiste-larchitecture-rest--h2br-">#</a></h2>
<p>Commençons par l&rsquo;architecture REST bien connue. L&rsquo;architecture REST suit un <a href="https://whatis.techtarget.com/definition/stateless">modèle sans état</a>, ce qui signifie que chaque service porte en lui toutes ses métadonnées. Ses messages, également appelés charges utiles, sont stockés au format JSON.</p>
<p>En outre, il est plus facile d&rsquo;intercepter les demandes non désirées de vos clients en utilisant REST. L&rsquo;architecture utilise des <a href="https://restfulapi.net/http-methods/">méthodes http</a> pour ses interactions avec les services. Les méthodes sont des composants qui suivent les mêmes <a href="https://www.techtarget.com/searchdatamanagement/definition/CRUD-cycle?_gl=1*14yg8z1*_ga*Mzg5NjExNjY2LjE2NDI4MDE1MzY.*_ga_TQKE4GS5P9*MTY0NjE3MTM2NS41LjEuMTY0NjE3MTk4NC4w&amp;_ga=2.113472391.1839572985.1646171366-389611666.1642801536">CRUD operations</a> trouvées sur les applications de <a href="https://www.techtarget.com/searchdatamanagement/definition/relational-database">base de données relationnelle</a> pour conserver l&rsquo;indépendance de vos transactions et la cohérence de vos données.</p>
<p>Lorsque vous utilisez ces méthodes, vos données restent cohérentes dans toutes les couches de votre application. Et grâce à ces caractéristiques, les appels REST peuvent gérer votre <a href="https://restfulapi.net/resource-naming/">maintenance des ressources</a> de manière plus fluide, même lorsque la connectivité réseau peut poser problème.</p>
<p>Les applications RESTful sont également capables de stocker localement les données les plus utilisées côté client ; technique appelée <a href="https://restfulapi.net/caching/">mise en cache</a>. Ce faisant, les services REST accèdent aux services les plus récurrents, ce qui permet de réduire la latence et la bande passante. Il devient plus rapide puisque les données demandées sont stockées localement pendant que la session est active. Dans ce cas, votre service web renvoie la version en cache de vos informations recueillies par un appel précédent. Il existe certaines <a href="https://restfulapi.net/security-essentials/">procédures de contrôle de la sécurité</a> pour atténuer certains problèmes. Ces procédures ne sont pas seulement liées à la politique de mise en cache persistante pour éviter l&rsquo;utilisation de données non pertinentes et gérer l&rsquo;infrastructure et la protection des données pour vos <a href="https://en.wikipedia.org/wiki/Data_in_transit">données en transit</a> et vos <a href="https://en.wikipedia.org/wiki/Data_at_rest">données au repos</a>. Jetez un coup d&rsquo;œil à l&rsquo;architecture RESTful de haut niveau ci-dessous.</p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/78096758/217092492-4ed0fab0-9372-40c6-960b-7e2cea8698d3.png" alt="Rest"  />

<em>Architecture de service web RESTFul.</em></p>
<p>J&rsquo;espère que cela vous permettra de vous familiariser ou de vous rafraîchir la mémoire sur le fonctionnement de l&rsquo;architecture RESTful. Ensuite, nous allons explorer les problèmes qu&rsquo;elle peut résoudre.
<br /><br /></p>
<h2 id="h3défis-que-nous-pouvons-résoudre-avec-resth3br-"><h3>Défis que nous pouvons résoudre avec REST</h3><br /><a hidden class="anchor" aria-hidden="true" href="#h3défis-que-nous-pouvons-résoudre-avec-resth3br-">#</a></h2>
<p>Nous pouvons commencer par dire que l&rsquo;API REST existe depuis un certain temps et qu&rsquo;elle est plus mature que gRPC. Naturellement, elle bénéficie d&rsquo;un meilleur support et d&rsquo;une documentation de meilleure qualité puisqu&rsquo;elle a subi de nombreux tests de résistance au fil des ans. En vous permettant d&rsquo;intégrer plus facilement de nouvelles sources de données dans vos pipelines de données ; en lui permettant de rester plus proche de vos sources de données. Réduire les problèmes liés au réseau au sein de votre écosystème et au transit des données dans et hors de vos flux de données.</p>
<p>En utilisant le framework REST, vous devez développer chaque code d&rsquo;éditeur et d&rsquo;abonné, ce qui permet une logique de transformation de données supplémentaire nécessaire pour transmettre correctement vos données entre les services. Un autre avantage provient d&rsquo;un cadre plus robuste, rendant l&rsquo;intégration de votre équipe plus facile à gérer en utilisant des technologies éprouvées pour gérer votre charge de travail. Lorsque vos messages sont dans un format convivial comme JSON, l&rsquo;audit de vos pipelines devient moins pénible lorsqu&rsquo;une défaillance se produit.</p>
<p>Chaque point de terminaison intègre sa documentation dans le code, ce qui rend l&rsquo;API REST plus facile à utiliser pour les humains. Ses actions suivent une structure simple, les activités étant décrites par des verbes. Il est plus logique, par exemple, que la méthode GET soit utilisée pour accéder à des enregistrements. De plus, les API REST sont remarquablement bien structurées, ce qui aide leurs responsables et leurs utilisateurs à améliorer les applications existantes.
Maintenant que nous avons vu ce que REST peut faire pour nous, examinons gRPC.
<br /><br /></p>
<h2 id="h2quest-ce-que-grpc--h2br-"><h2>Qu&rsquo;est-ce que gRPC ? </h2><br /><a hidden class="anchor" aria-hidden="true" href="#h2quest-ce-que-grpc--h2br-">#</a></h2>
<p>The <a href="https://grpc.io/">gRPC framework</a> is an extension of remote procedure calls. In addition to using simple messages, this framework allows multiple message requests on the same connection. And it gets better with the support of <a href="https://grpc.io/docs/what-is-grpc/core-concepts/#bidirectional-streaming-rpc">bidirectional data streaming</a>. This feature turns the gRPC into a powerful ally. You will be able to handle multiple independent, nonrelated threads.</p>
<p>The gRPC framework uses protocol buffers (or <a href="https://developers.google.com/protocol-buffers/docs/overview">protobuf</a>) under the hood, allowing evolutive schema support for your streaming data. You can avoid some of the trouble of having different JSON payloads from your sources as there is no need for client libraries to handle data cleansing jobs like auditing missing JSON fundamental values.</p>
<p>In addition to removing some of your business logic while extracting data from your API calls, protocol buffers are more optimal. Your data pipelines become more performant, and as a result, you can feel the network latency of your data ingestion channels lowered even with the smaller chunks of data. It becomes easier to correlate different data sources with adaptive client-server libraries generation based on your original protobuf file.
<br /><br /></p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/78096758/217093080-4040c5d0-9e4e-4d5e-a143-4e1069e70606.png" alt="grpc-architecture"  />

<em>gRPC connectivity overview.</em></p>
<p>Consultez le <a href="https://developers.google.com/protocol-buffers/docs/proto3#simple">Guide de langage des tampons de protocole</a> pour une analyse plus approfondie de la configuration de votre message. Voyons maintenant ce que nous pouvons résoudre à l&rsquo;aide de gRPC.
<br /><br /></p>
<h2 id="h3des-défis-que-nous-pouvons-résoudre-avec-grpch3br-"><h3>Des défis que nous pouvons résoudre avec gRPC.</h3><br /><a hidden class="anchor" aria-hidden="true" href="#h3des-défis-que-nous-pouvons-résoudre-avec-grpch3br-">#</a></h2>
<p>gRPC a un avantage significatif : il peut créer un client pour deux <strong><em>clients sur différents langages de programmation</em></strong> dès le départ. En soi, cela rend l&rsquo;adoption de vos sources plus accessible du point de vue du développement, et vous n&rsquo;aurez pas besoin de tout un pipeline de développement pour les changements dans vos bibliothèques clientes. En modifiant simplement votre fichier proto, le <a href="https://grpc.io/docs/languages/">langage de programmation</a> ou la <a href="https://grpc.io/docs/platforms/">plate-forme</a> de votre choix peut facilement reproduire ses modifications. De plus, votre fichier proto peut même définir l&rsquo;acheminement des messages, ce qui évite de devoir le configurer sur chacun des codes producteurs ou consommateurs.</p>
<p>Une autre caractéristique intéressante de gRPC est qu&rsquo;il est nettement plus rapide que HTTPS et que la taille des messages est plus légère que celle de JSON (<a href="https://auth0.com/blog/beating-json-performance-with-protobuf/)">https://auth0.com/blog/beating-json-performance-with-protobuf/)</a>. Cela le rend essentiel lorsque différents langages de programmation consomment votre service. En utilisant gRPC, vous n&rsquo;aurez pas à vous battre autant pour gérer votre communication. Bien que cela puisse être très tentant, un déploiement réussi dépendra de la maturité de votre écosystème pour le permettre.
<br /><br /></p>
<h2 id="h2conclusionh2br-"><h2>Conclusion</h2><br /><a hidden class="anchor" aria-hidden="true" href="#h2conclusionh2br-">#</a></h2>
<p>J&rsquo;ai couvert les protocoles de communication utilisés sur deux architectures de microservices, les frameworks gRPC et REST. Il peut sembler intéressant d&rsquo;adopter gRPC car il est plus rapide et plus vite adopté, mais vous risquez de vous créer beaucoup d&rsquo;ennuis en ajustant vos pipelines de traitement. La raison principale vient de la façon dont gRPC traite les messages. Vous pouvez y remédier avec le protobuf <a href="https://developers.google.com/protocol-buffers/docs/proto3#json">mappage JSON</a> prêt à l&rsquo;emploi, mais vous devrez tout de même modifier vos services REST existants pour qu&rsquo;ils interagissent avec les nouveaux services gRPC. Gardez à l&rsquo;esprit que tous les navigateurs ne prennent pas en charge toutes les fonctionnalités de gRPC, et qu&rsquo;il ne s&rsquo;agit donc pas d&rsquo;un excellent cadre de travail pour l&rsquo;utilisateur.</p>
<p>Vous aurez besoin d&rsquo;un plan technique bien conçu pour faire passer votre architecture de REST à gRPC. Mais vous obtiendrez un meilleur plan d&rsquo;observabilité. Le fait d&rsquo;avoir vos données dans un format non humain peut renforcer votre sécurité car vos données ne seront pas en texte clair.</p>
<p>Il est également bon de renforcer que Aucune approche ne fonctionnera bien sans une analyse de sécurité robuste, c&rsquo;est une bonne idée de revoir vos règles en fonction des métriques de votre trafic de données.</p>
<p>Si vous avez besoin d&rsquo;aide pour transformer vos données, vous pouvez <a href="https://calendly.com/dawrlog">nous contacter</a> pour toute question et même découvrir de nouvelles informations dont vous n&rsquo;étiez pas conscient grâce à une meilleure compréhension de vos données.</p>
<p>À+!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://www.dawrlog.com/fr/articles/8/">
    <span class="title">« Page précédente</span>
    <br>
    <span>Chargements des données incrementels: Un moyen nickel de charger vos données.</span>
  </a>
  <a class="next" href="https://www.dawrlog.com/fr/articles/5/">
    <span class="title">Page suivante »</span>
    <br>
    <span>Examples des ETL utilisant des workflows Argo.</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi? on twitter"
        href="https://twitter.com/intent/tweet/?text=gRPC%20vs%20REST%3a%20Lequel%20dois-je%20choisir%20pour%20mon%20application%20et%20pourquoi%3f&amp;url=https%3a%2f%2fwww.dawrlog.com%2ffr%2farticles%2f13%2f&amp;hashtags=APIDevelopment%2cSecurity%2cBestPractices">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi? on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.dawrlog.com%2ffr%2farticles%2f13%2f&amp;title=gRPC%20vs%20REST%3a%20Lequel%20dois-je%20choisir%20pour%20mon%20application%20et%20pourquoi%3f&amp;summary=gRPC%20vs%20REST%3a%20Lequel%20dois-je%20choisir%20pour%20mon%20application%20et%20pourquoi%3f&amp;source=https%3a%2f%2fwww.dawrlog.com%2ffr%2farticles%2f13%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi? on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fwww.dawrlog.com%2ffr%2farticles%2f13%2f&title=gRPC%20vs%20REST%3a%20Lequel%20dois-je%20choisir%20pour%20mon%20application%20et%20pourquoi%3f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi? on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.dawrlog.com%2ffr%2farticles%2f13%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi? on whatsapp"
        href="https://api.whatsapp.com/send?text=gRPC%20vs%20REST%3a%20Lequel%20dois-je%20choisir%20pour%20mon%20application%20et%20pourquoi%3f%20-%20https%3a%2f%2fwww.dawrlog.com%2ffr%2farticles%2f13%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share gRPC vs REST: Lequel dois-je choisir pour mon application et pourquoi? on telegram"
        href="https://telegram.me/share/url?text=gRPC%20vs%20REST%3a%20Lequel%20dois-je%20choisir%20pour%20mon%20application%20et%20pourquoi%3f&amp;url=https%3a%2f%2fwww.dawrlog.com%2ffr%2farticles%2f13%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://www.dawrlog.com/fr/">Logistique Dataware</a>; <br /> created with 🧡 on 🐧 machines running ☸️ pods.</span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script>
  kofiWidgetOverlay.draw('dawrlog', {
    'type': 'floating-chat',
    'floating-chat.donateButton.text': 'Tip jar',
    'floating-chat.donateButton.background-color': '#794bc4',
    'floating-chat.donateButton.text-color': '#fff'
  });
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copier';

        function copyingDone() {
            copybutton.innerHTML = 'Copié !';
            setTimeout(() => {
                copybutton.innerHTML = 'Copier';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
